#' This is the helper function for generating pseudo-bulk mixture
#'
#' @param ct_chosen Selected cell types in the mixture.
#' @param lower_thres The minimum proportion of a cell type.
#' @return Return the cell type proportion for selected cell types.
#'
create_mixture_helper <- function(ct_chosen, lower_thres = 0.05) {
  n <- length(ct_chosen)
  prop_dict <- rep(lower_thres, n)
  normalization_coef <- 1 - n * lower_thres
  stopifnot(normalization_coef > 0)

  temp <- sample(1:100, n, replace = TRUE)
  temp <- temp * normalization_coef / sum(temp)

  prop_dict <- prop_dict + temp

  return(setNames(prop_dict, ct_chosen))
}



#' This is to create a pseudo-bulk mixture
#'
#' @param df_demo_test The single cell profile used to generate pseudo-bulk mixtures.
#' @param ct_list List of existing cell types.
#' @return Return one pseudo-bulk mixture and its ground truth.
#'
create_mixture <- function(df_demo_test, ct_list) {
  num_ct_chosen <- sample(2:length(ct_list), 1)
  ct_chosen <- sample(ct_list, num_ct_chosen)
  ct_prop <- create_mixture_helper(ct_chosen)

  cell_list <- c()
  for (ct in ct_chosen) {
    num_ct_ref <- table(df_demo_test$Celltype)
    ct_prop[ct] <- as.integer(num_ct_ref[ct] * ct_prop[ct])
    cell_list <- c(cell_list, sample(which(df_demo_test$Celltype == ct), min(ct_prop[ct], num_ct_ref[ct])))
  }

  df_pseudo <- df_demo_test[-cell_list, ]
  col <- colSums(df_pseudo[, !(names(df_pseudo) %in% c('Celltype'))])

  return(list(ct_prop = ct_prop, col = col))
}

#' This is to create n pseudo bulk mixtures and their ground truths
#'
#' @param n Number of pseudo-bulk mixtures to be generated.
#' @param df Single cell data.
#' @param prop Proportion of cells used to generate pseudobulk mixtures.
#' @return Return n pseudo-bulk mixture and their ground truth.
#'
generate_pseudobulk <- function(n, df, prop=0.1) {
  df_with_rowid <- df %>%
    mutate(row_id = row_number())
  df_demo_test <- df_with_rowid %>%
    group_by(.data$Celltype) %>%
    sample_frac(prop)
  selected_id <- df_demo_test$row_id
  df_demo_test <- df_demo_test %>% select(-.data$row_id)

  df_demo_test <- as.data.frame(df_demo_test)
  ct_list <- unique(df_demo_test$Celltype)
  df_pseudobulk <- data.frame(matrix(0, n, ncol(df_demo_test)), stringsAsFactors = FALSE)
  colnames(df_pseudobulk) <- colnames(df_demo_test)
  df_pseudobulk <- df_pseudobulk[, !(names(df_pseudobulk) %in% c('Celltype'))]
  df_groundtruth <- data.frame(matrix(0, n, length(ct_list)), stringsAsFactors = FALSE)
  colnames(df_groundtruth) <- ct_list

  for (i in 1:n) {
    result <- create_mixture(df_demo_test, ct_list)
    prop <- result$ct_prop
    mix_raw <- result$col

    df_pseudobulk[i, ] <- mix_raw

    for (ct in colnames(df_groundtruth)) {
      tryCatch({
        df_groundtruth[i, ct] <- prop[ct] / sum(unlist(prop))
      }, error = function(e) {
        df_groundtruth[i, ct] <- 0
      })
    }
  }

  df_groundtruth <- apply(df_groundtruth, 2, function(x) replace(x, is.na(x), 0))

  return(list(df_pseudobulk = as.matrix(t(df_pseudobulk)), df_groundtruth = df_groundtruth, selected_id = selected_id))
}



#' This is the function for CosGeneGate deconvolution - pseudobulk mode
#'
#' @param sc_profile File directory for single cell reference file.
#' @param mkg_file Marker gene file generated by CosGeneGate.
#' @param index Numbe of marker genes to be iterated.
#' @param prop Proportion of cells remained in the reference profile. The rest of the cells will be used to generate pseudobulk mixtures.
#' @param n Number of pseudobulk mixtures to be generated.
#' @param plot_line TRUE to plot the graph of error vs. # of marker genes, FALSE otherwise.
#' @return Return the optimized single cell reference profile.
#'
#' @importFrom stats setNames
#' @export deconvolution_pseudobulk_mode
#'
deconvolution_pseudobulk_mode <- function(sc_profile,
                                          mkg_file,
                                          index = c(2,3,4,5,6,7,8,9,10,12,14,16,18,20,25,30,35,40,45,50),
                                          prop=0.9,
                                          n=50,
                                          plot_line=FALSE) {
  # Read single cell data
  sc.ref <- readH5AD(sc_profile)
  names(assays(sc.ref)) <- "counts"
  # Read markers
  marker.gene <- read.csv(mkg_file, sep='\t', check.names=FALSE)
  marker.gene <- marker.gene[, !(names(marker.gene) %in% c('X'))]
  # Generate pseudobulk data
  counts_matrix <- assays(sc.ref)$counts
  df <- as.data.frame(t(counts_matrix))
  df$Celltype <- sc.ref$label
  pseudo_bulk <- generate_pseudobulk(n, df, 1-prop)
  sc_ref.new <- sc.ref[,-pseudo_bulk$selected_id]

  mk.test <- hash()
  mk.test.index <- index
  # mk.test.index <- c(45,50)
  for (npct in mk.test.index) {
    mkg <- c()
    for (ct in colnames(marker.gene)) {
      mkg <- c(mkg, marker.gene[0:npct, ct])
    }
    mk.test[npct] <- mkg
  }
  mk.test.RMSE <- hash()
  plt.RMSE <- c()
  for (npct in mk.test.index) {
    decon <- music_prop(bulk.mtx = pseudo_bulk$df_pseudobulk,
                        sc.sce = sc_ref.new,
                        clusters = 'label',
                        samples = 'sample_id',
                        markers=mk.test[[as.character(npct)]])
    # return(list(test1=decon$Est.prop.weighted, test2=pseudo_bulk$df_groundtruth))
    mk.test.RMSE[npct] <- mean(Calculate_RMSE(decon$Est.prop.weighted, pseudo_bulk$df_groundtruth))
    plt.RMSE <- c(plt.RMSE, mean(Calculate_RMSE(decon$Est.prop.weighted, pseudo_bulk$df_groundtruth)))
  }
  min_err <- min(unlist(as.list(mk.test.RMSE)))
  num_marker <- names(which(unlist(as.list(mk.test.RMSE)) == min_err))
  optimal_marker <- mk.test[[num_marker]]
  if (plot_line == TRUE) {
    plot(index, plt.RMSE, type = "b", pch = 19, col = "black", xlab = "Number of markers per cell type", ylab = "Mean RMSE")
  }
  return(sc.ref[optimal_marker])
}

